---
layout: post
title: Pig
subtitle: A Communication Primitive to Form Quorums
# cover-img: /assets/img/path.jpg
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [Communication primitive, Consensus, Quorum, Communication bottleneck]
# author: Hasan Heydari
---

The leader constitutes a communication bottleneck in leader-based state machine replication (SMR) protocols like Multi-Paxos and HotStuff.
Specifically, in each phase of a consensus instance, a non-leader process (follower) receives one message from the leader and sends one message back; however, in a system with $n$ processes, the leader needs to send $n-1$ messages to the followers, and receive at least a quorum of messages back from them.
Therefore, scaling such protocols requires reducing the disproportionate load on the leader.
[PigPaxos: Devouring the Communication Bottlenecks in Distributed Consensus](https://dl.acm.org/doi/pdf/10.1145/3448016.3452834) addresses communication bottleneck imposed by leaders and improves the throughput of leader-based SMR protocols by introducing Pig, a communication primitive to form quorums.
Before delving into Pig, let us see how quorums are formed in most SMR protocols, such as Multi-Paxos and HotStuff.

#### Traditional quorum formation protocols
Assume that the size of any quorum is $q$.
Consider a process $i$ that intends to form a quorum.
We need to take the following steps:
1. Process $i$ sends a request to all processes.
2. Upon receiving $i$'s request, a process sends a response to $i$.
3. Upon receiving $q$ responses from different processes, $i$ considers the received responses as a quorum.

We are now ready to see how Pig forms quorums.

#### Pig: a communication primitive to form quorums
Pig is a communication primitive to form quorums.
Again, assume that the size of any quorum is $q$, and suppose a process $i$ intends to form a quorum.
In Pig, we need to take the following steps:
1. Process $i$ starts a timer $t_{relays}$ and sends a request to a group of processes called *relays*.
2. Upon receiving a request from $i$, a relay process $j$ takes the following steps:
    - Process $j$ starts a timer $t_{followers}$ and sends the received request to its followers (i.e., a group of processes that follow $j$.)
    - Upon receiving a request from $j$, a follower sends a response to $j$.
    - Process $j$ waits until happening one of the following events:
       Either receiving responses from a predefined number of its followers, or
       expiring $t_{followers}$.
     - Process $j$ sends the set of received responses to process $i$.
3. Process $i$ waits until happening one of the following events:
   Either receiving responses from at least $q$ distinct processes, 
   or expiring $t_{relays}$.
   In the latter case, it goes to Step 1. 

**Remarks.**
- The set of relay processes can be static (i.e., pre-configured) or dynamic.
- The set of followers of a relay process can overlap with the set of followers of another relay process.
