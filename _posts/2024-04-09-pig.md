---
layout: post
title: Pig
subtitle: A Communication Primitive to Form Quorums
# cover-img: /assets/img/path.jpg
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [Communication primitive, Consensus, Quorum, Communication bottleneck]
# author: Hasan Heydari
---

The leader constitutes a communication bottleneck in leader-based state machine replication (SMR) protocols like Multi-Paxos and HotStuff.
Specifically, in each phase of a consensus instance, a non-leader process (follower) receives one message from the leader and sends one message back; however, in a system with $n$ processes, the leader needs to send $n-1$ messages to the followers, and receive at least a quorum of messages back from them.
Therefore, scaling such protocols requires reducing the disproportionate load on the leader.
[PigPaxos: Devouring the Communication Bottlenecks in Distributed Consensus](https://dl.acm.org/doi/pdf/10.1145/3448016.3452834) addresses communication bottleneck imposed by leaders and improves the throughput of leader-based state machine replication protocols by introducing Pig, a communication primitive to form quorums.
Before delving into Pig, let us see how quorums are formed in most SMR protocols, such as Multi-Paxos and HotStuff.

#### Traditional quorum formation protocols
Assume that the size of any quorum is $q$.
Consider a process $i$ that intends to form a quorum.
We need to take the following steps:
1. Process $i$ sends a request to all processes.
2. Upon receiving $i$'s request, a process sends a response to $i$.
3. Upon receiving $q$ responses from different processes, $i$ considers the received responses as a quorum.

#### Pig: a communication primitive to form quorums
Pig is a communication primitive to form quorums.
Assume that the size of any quorum is $q$.
Consider a process $i$ that intends to form a quorum.
In Pig, we need to take the following steps:
1. Process $i$ starts a timer $t_{relays}$ and sends a request to a group of processes called *relays*.
2. Upon receiving a request from $i$, a relay process $j$ takes the following steps:
    - Process $j$ starts a timer $t_{follower}$.
    - Process $j$ sends the received request to its followers (i.e., a group of processes that follow $j$.)
    - Upon receiving $j$'s request, a follower sends a respond to $j$.
    - Process $j$ waits until happening one of the following events:
       Either receiving responses from a predefined number of its followers, or
       Its timer ($t_{follower}$) finishes.
       Then it sends the received response to process $i$.
3. Process $i$ until happening one of the following events:
   Either receiving responses from at least $q$ distinct followers, or
   Its timer ($t_{relays}$) finishes. In this case, it goes to Step 1. 


**Remarks.**
- The set of relay processes can be static (i.e., pre-configured) or dynamic.
- 
